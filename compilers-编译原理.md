# 编译原理 龙书

## 引论 

### 语言处理器
* 编译器就是一个程序，阅读某一语言(源语言)这天的程序，并把程序翻译成一个等价的用另一个语言(目标语言)编写的程序。重要任务之一是翻译过程中发现源程序的错误。
* 解释器不用翻译的方式生成目标程序。从用户角度看，直接利用用户提供的源程序做操作。
* 编译器产生的目标程序通常比解释器快。但解释器的错误诊断效果好。

### 一个编译器的结构
* 两个部分：分析和综合
* 分析部分：把源程序分成多个组成元素，并在这些元素上加入语法结构。然后使用这个语法结构来创建这个源程序的中间表示。收集源程序的信息，把信息放在符号表里。符号表和中间表示一起传递给综合部分。
* 综合部分：根据中间表示和符号表中的信息构造用户期待的目标程序。
* 分析部分==编译器的前端；综合部分==编译器的后端。
* 步骤：
    1. 词法分析(lexical analysis)或扫描器(scanning): 词法分析器读入源程序的字符流，并组成有意义的词素(lexeme)序列。对于每个词素，产生词法单元(token)做为输出：
    **$\langle$token-name,attribute-value$\rangle$**.
    这个词法单元被传输给下一步语法分析。token-name是语法分析中使用的抽象符号，attribute-value是符号表中关于这个词法单元表示的条目。
    2. 语法分析(syntax analysis)或解析(parsing),使用词法分析器生成的各个词法单元的第一个变量来创建树形的中间表示。该中间表示给出了词法单元流的语法结构。常用的表示方法是语法树(syntax tree).树中的每个结点表示一个运算，而该结点的子结点表示该运算的分量。
    3. 语义分析(semantic analsis),语义分析器使用语法树和符号表中的信息来检索源程序是否和定义的语法一致。同时也收集类型信息，把这些信息放到语法树或符号表中，以便在后面的中间代码生成中使用。这步最重要的是类型检查(type checking).
    4. 中间代码生成，在把源程序翻译成目标代码的过程中，一个编译器可能构造出一个或多个中间表示 。这些中间表示可以有多种形式。语法树是一种中间表示 ，通常在语法分析和语义分析中使用。在源程序的语法分析和语义分析完成之后，很多编译器生成一个明确的代级的类机器语言的中间表示。该中间表示有两个重要的性质：易于生成且能被轻松翻译为目标机器上的语言。
    5. 代码优化。机器无关的代码优化步骤试图改进中间代码，以便生成更好的目标代码。
    6. 代码生成。代码生成器以源程序的中间表示形式做为输入，并把它映射到目标语言。如果目标语言是机器代码，那么就必须为程序使用的每个变量选择寄存器或内存位置。然后中间指令被翻译成能够完成伤务的机器指令序列。
    7. 符合表管理。符合表数据结构为每个变量创建一个记录条目。记录的字段就是名字的各个属性。这个数据结构应该允计编译器迅速找到个每个名字的记录，并向记录中快速存放和获取记录中的数据。
    8. 将多个步骤组合成pass。多个步骤可以组成一个pass，每个pass读入一个输入文件并产生一个输出文件。词法分析，语法分析，语义分析，中间代码生成组合在一起叫做编译器的前端，后面的步骤为编译器的后端。
* 编译器构造工具
    1. 语法分析器的生成器：可以根据程序设计语言的描述自动生成语法分析器。
    2. 扫描器的生成器：根据一个语言的语法单元的正则表达式描述生成词法分析器。
    3. 语法制导的翻译引擎：可以生成一组用于遍历分析树并生成中间代码的例程。
    4. 代码生成器的生成器：依据一组关于如何把中间语言的每个运算翻译成目标机上的机器语言规则，生成一个代码生成器。
    5. 数据流分析引擎：可以帮助收集数据流信息，即程序中的值如何从程序的一个部分传递到另一个部分。数据流分析是代码优化的一个重要部分。
    6. 编译器构造工具集：提供了可用于构造编译器的不同阶段的例程的完整集合。

### 程序设计语言的发展历程
第一代机器语言，第二代汇编语言，第三代高级程序设计语言，第四代为特定应用设计的语言，第五代语言指基于逻辑和约束的语言。

命令式语言和声明式语言

### 构建编译器的相关科学
* 编译器优化要满足的目标：
    * 优化必须是正确的
    * 优化必须能改状况很多程序的性能
    * 优化所需的时间必须保证在合理的范围
    * 所需要的工程方面的问题必须是可管理的

### 编译技术的应用
* 高性能系统利用的两种技术：并行(parallelism)和内存层次结构(memory hierarchy).在指令层次上多个运算可以被同时执行；在处理器层次上同一个应用的不同线程在不同的处理器上执行。

### 程序设计语言基础
* 静态和动态的区别：在编译时刻决定为静态，在运行程序时做决定为动态。
* 仅通过阅读程序就可以确定一个声明的作用域，是静态作用域(static scope)或词法作用域(lexical scope)，否则是动态作用域。
* 环境和状态。
    * 环境是一个从名字到存储位置的映射。也可称为从名字到变量的映射。
    * 状态是一个从内存位置到它们的值的映射。
* 静态作用域和块结构
* 显示访问控制 java中的public、private、protected
* 动态作用域 一个作用域策略信赖于一个或多个只有在程序执行时才能知道的因素，它就是动态的。
* 参数传递机制 
    * 值调用(call-by-value)会对实际参数求值(如果它是表达式)或拷贝(如果它是变量)。这些值被放在属于被调用过程的相应形式参数的内存位置上。效果是被调用的过程所有有关形式参数的计算都局限于这个过程，相应的实际参数本身不会改变。
    * 引用调用(call-by-reference)，实际参数的地址作为相应形式参数的值被传递给调用者。在被调用者的代码使用形式参数时，实现方法是沿着这个指针找到调用者指明的内存位置。因此改变形式参数就像是改变了实际参数一样。但是如果实际参数是表达式，那么在调用之前会对表达式求值，然后它的值被放在一个该值自己的位置上。改变形式参数会改变这个值，但对调用者的数据没有影响。
    * 名调用，
* 别名 

## 一个简单的语法制导翻译器
### 引言 
语法是描述该语言程序的正确形式，语义定义了程序的含义。
面向文法的翻译技术即语法制导翻译(syntax-directed translation).

### 语法定义
上下文无关文法，简称文法，被用于编译器的前端。方法自然的描述了大多数程序设计语言构造的层次化语法结构。关键字括号之类称为终端符号，变量表示的终结符号的序列，叫非终端符号。
* 一个上下文无关文法由四个元素组成：
    1. 一个终结符号集合，有时称为词法单元
    2. 一个非终结符号集合，有时称为语法变量。每个非终结符号表示一个终结符号的集合。
    3. 一个产生式集合，其中每个产生式包括一个称为产生式头或左部的非终结符号，一个箭头，和一个称为产生式体或右部的由终结符号及非终结符号组成的序列。主要用来表示某种构造的书写形式。
    4. 指定一个非终结符号为开始符号。

* 推导，我们首先从开始符号出发，不断将某个非终结符号替换成该非终结符号的某个产生式体。可以从开始符号推导得到所有终结符号串的集合称为该文法的语言。
* 语法分析树 一个文法的语法分析树具有以下性质：
    1. 根结点的标号为文法的开始符号。
    2. 每个叶子结点的标号为一个终结符号或空。
    3. 每个内部结点的标号为一个非终结符号。
    4. 如果非终结符号A是某个内部结点的标号，并且它的子结点的标号从左到右分别为X<sub>1</sub>,X<sub>2</sub>,...,X<sub>n</sub>,那么必然存在产生式A$\to$X<sub>1</sub>X<sub>2</sub>...X<sub>n</sub>,其中X<sub>1</sub>X<sub>2</sub>...X<sub>n</sub>既可以是终结符号也可以是非终结符号。
* 二义性，一个文法可能有多棵语法分析树能够生成同一个给定的终结符号串。
* 运算符的结合性和优先级