# 计算的本质：深入剖析程序和计算机 Understanding Computation From Simple Machines to Impossible Programs

## ruby 基础

Ruby 是一种面向表达式的语言:每一段有效的代码执行之后都要产生一个值。

Ruby 支持布尔型(Boolean)、数值型(number)和字符串(string)，且它们都支持常规运算。

## 程序的含义

在一台计算机读取程序、运行程序、读入一些输入，并且最后产生一些输出的时候，肯定发生 了某种计算。因此我们可以这样认为:计算就是指计算机所做的事情。

为了创造一个越来越亲让计算发生需要三个基本要素：
* 一台机器 能够执行计算
* 一种语言 用来编写这台机器能够理解的指令
* 一个程序 用这种语言编写，描述机器应该具体执行哪些计算

计算机编程不单是与程序相关，重要的是程序员要表达的思想。程序只是思想的静态 表示，是曾经存在于程序员脑海中的某个结构的快照。程序是因为有了含义才值得写下来。

### “含义”的含义

在语言学中，语义学(semantics)研究的是单词和它们含义之间的关系。语义不止关注抽象含义本身的基本性质，还关注具体的记号如 何与它们的抽象含义关联起来。

计算机科学里，形式语义学注重找到确定程序难以捉摸的含义的方法，并利用这些方法发 现或者证明编程语言中有趣的东西。

为了完整地定义编程语言，我们需要:语法，描述程序看起来是什么样的;语义(semantics)1， 描述程序的含义。

### 语法

计算机程序的预期用途是被计算机读取，而要读程序就需要语法解析器:这个分析 器程序能够读取代表程序的字符串，根据语法规则检查它是否有效，然后把它转换成一个 适合被进一步处理的结构化表示。

语法关心的只是程序的表面是什么样的，而不是它的含义。程序有可能语法正确但没有任 何实际意义。

实际上，关于程序的含义有几种不同的研究方法，它们都在形式化 (formality)、 抽 象 度(abstraction)、 可 表 达 性(expressiveness) 和 实 际 效 率(efficiency) 之间做了权衡。

### 操作语义

操作语义学(operational semantic)的基础，为程序在某种机器上的执行定义一些规则，以此来捕捉编程语言的含义。这个机器常常是一种抽象的机器:为了解释这种 语言所写的程序如何执行而设计出来的一个想象的、理想化的计算机。为了更好地捕获编 程语言的运行时行为，通常需要针对不同种类的编程语言设计不同的抽象机器。

大步语义的思想是，定义如何从一个表达式或者语句直接得到它的结果。这必然需要把程 序的执行当成一个递归的而不是迭代的过程:大步语义说的是，为了对一个更大的表达式 求值，我们要对所有比它小的子表达式求值，然后把结果结合起来得到最终答案。

### 指称语义

指称语义(denotational semantic)转而关心从程序本 来的语言到其他表示的转换。

### 形式化语义实践

形式化语义的一个重要应用是为一种编程语言的含义给出一个无歧义的定义，而不是让其 依赖于像自然语言规范文档和“由实现规范”这样更加随意的方法。

小步语义还叫结构化操作语义(structural operational semantic)和转换语义(transition semantic);大步语义更普遍的叫法是自然语义(natural semantic)或者关联语义(relational semantic);而指称语义还可以称为不动点 语义(fixed-point semantic)或者数学语义(mathematical semantic)。公理化语义(axiomatic semantic)，它通过在 语句执行前后分别给出抽象机器状态的断言来描述一个语句的含义:如果一个断言(前置 条件)在语句执行前初始是 true，那么随后的其他断言(后置条件)将是 true。公理化语义在验证程序的正确性方面很有用:随着语句合到一起组成更大的程序，它们对应的断言也能合到一起组成更大的断言，其目标就是表明对一个程序总体的断言与它的预期定义匹配。
  
## 最简单的计算机

### 确定性有限自动机

有限状态机(finite state machine)，也叫有限自动机(finite automaton)，是一台计算机的极简模型。

有限自动机没有持久化的存储并且几乎没有 RAM。它只是一台小机器，拥有一些可能的状态，并能够跟踪到自己当前具体处于其中的哪个状态——试着把它看成一台 RAM 只够存储一个值的计算机。同样，有限自动机没有键盘、鼠标和接收输入的网络接口，只有一 个外部的字符输入流可以一次读取一个字符。

每台有限自动机没有通用的 CPU 执行任意程序，而是硬编码了一些规则集合，以决定在相应的输入下如何从一个状态切换到另一个状态。自动机先从一个特定的状态开始，然后从输入流中读入字符——按照规则它每次读取一个字符。

只要满足下面两个约束，就能保证这种确定性。
* 没有冲突 不存在这样的状态:它的下一次转换状态因为有彼此冲突的规则而有二义性。 (这意味着一个状态对于同样的输入，不能有多个规则。)
* 没有遗漏 不存在这样的状态:它的下一次转换状态因为缺失规则而未知。(这意味着 每个状态都必须针对每个可能的输入字符有至少一个规则。)

### 非确定性有限自动机

对于一台 NFA 来说，什么才能表示一台 NFA 接受或者拒绝一个字符串呢?很自然的回答是，如果存在某条路径能让 NFA 按照它的某些规则执行 并终止于一个接受状态，那它就能接受这个字符串 ; 这就是说，即使不是必然的，只要终止于一个接受状态是可能的就可以。

一台 NFA 按照可能性而不是确定性工作:我们根据可能发生的而不是将要发 生的来讨论它的行为。

### 正则表达式

### 等价性



## 增加计算能力

## 终极机器

## 从零开始编程

## 通用性无处不在

## 不可能的程序

## 在“玩偶国”中编程

  