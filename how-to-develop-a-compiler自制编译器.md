
# 自制编译器 

### 1. 开始制作编译器

编译器是将编程珏的代码转换为其他形式的软件。转换操作称为编译。

4个阶段：
1. 预处理
2. 编译（狭义的）
3. 汇编
4. 链接

狭义的编译的四个阶段
1. 语法分析
2. 语义分析
3. 生成中间代码
4. 代码生成

### 2. Cb和cbc



## 第一部分 代码分析

### 3. 语法分析的概要

#### 1. 语法分析的方法

分析算式时，一定要考虑运算符的优先级（operator precedence）。

词法分析(lexical analyze)就是将代码分割为一个个的单词，也可以称为扫描(scan)。

负责词法分析的模块称为词法分析器(lexical analyzer)，又称扫描器(scanner)。

一般情况下，空白符和注释都是在词法分析阶段进行处理的。

扫描器的工作不仅仅是将代码分割成单词，在分割的同时还会推算出单词的种类，并为单词添加语义值。

单词的种类是指该单词在语法上的分类，例如单词“54”的种类是“整数”。

语义值(semantic value)表示单词所具有的语义。

另外，也有一些单词本身不存在语义值。例如，对于保留字 int 来说，“保留字 int”这 样的种类信息已经完全能够表示语义，不需要额外的语义值。

在编程语言处理系统中，我们将“一个单词(的字面)”和“它的种类”“语义值”统称为 token。通过使用 token 这个词，词法分析器的作用就可以说是解析代码(字符行)并生成 token 序列。

编程语言的编译器中解析器的主要作用是解析由扫描器生成的 token 序列，并生成代码所对应的树型结构，即语法树。语法树和语法是完全对应的。

无论语法树还是抽象语法树，都是树形的数据结构，因此和普通的树结构相同，由称为节点（node）的数据结构组合而成。

#### 2. 解析器生成器

生成扫描器的程序称为扫描器生成器（scanner generator），生成解析器的程序称为解析器生成器（parser generator）。

扫描器生成器都大体类似，解析器生成器则有若干个种类。现在具有代表性的解析器生成器可分为 LL 解析器生成器和 LALR 解析器生成器两类。

种类  | 可处理的语法范围 | 速度
---- | -------------- | ----
LR   | 广             | 一般
LALR | 相对狭窄        | 一般
LL   | 较窄            | 较快

在“可处理语法的范围”一列中，有的像 LALR(1) 这样，标注了 (1) 这样的数字。这表示能够超前扫描的 token 数，其中 (k) 或 (*) 表示能够超前扫描任意个数。基本上可以认为这个数字越大解析器生成器的功能就越强。

解析器生成器称为编译器的编译器（compiler●compiler）。

#### 3. JavaCC 的概要

JavaCC 是 LL 解析器生成器，因此比起 LR 解析器生成器和 LALR 解析器生成器，它有着 可处理语法的范围相对狭窄的缺点。JavaCC 是 LL 解析器生成器，因此比起 LR 解析器生成器和 LALR 解析器生成器，它有着可处理语法的范围相对狭窄的缺点。但另一方面，JavaCC 生成的解析器有易于理解、易于使用的优势。另外，因为支持了“无限长的 token 超前扫描”，所以可处理语法范围狭窄的问题也得到了很好的改善。

语法规则通常会用一个扩展名为“.jj”的文件来描述，该文件称为语法描述文件。语法形式：
```
options {
JavaCC 的选项
}
PARSER_BEGIN( 解析器类名 )
package 包名 ;
import 库名 ;
public class 解析器类名 {
任意的 Java 代码
}
PARSER_END( 解析器类名 )
扫描器的描述
解析器的描述
```
    
### 4. 词法分析

#### 1. 基于 JavaCC 扫描器的描述

JavaCC 采用正则表达式(regular express)的语法来描述需要解析的单词的规则，并由此来表现扫描器。

#### 2. 扫描没有结构的单词

JavaCC 中扫描 token 要像下面这样使用 TOKEN 命令(TOKEN directive)，并排记载 token 名和正则表达式。

```
TOKEN: {
      <token名1 : 正则表达式1>
    | <token名2 : 正则表达式2>
    | <token名3 : 正则表达式3>
          .
          .
          .
    | <token名n : 正则表达式n> 
}
```

JavaCC 会同时尝试匹配所有的正则表达式，并选择匹配字符串最长的规则。像这样和多个规则的正则表达式匹配的字符串长度相同的情况下，JavaCC 优先选择在文件中先定义的 token 规则。

#### 扫描不生成 token 的单词

不使用 TOKEN 命令而使用 SKIP 命令的话就不会生成 token，因此使用 SKIP 命令可以省略 token 名。

还可以用 SPECIAL_TOKEN 命令(SPECIAL_TOKEN directive)来跳过 token。SKIP 命令 和 SPECIAL_TOKEN 命令的区别在于是否保存跳过的 token。使用 SKIP 命令无法访问跳过的字 符串，使用 SPECIAL_TOKEN 命令就可以借助下面被扫描的 TOKEN 对象来取得跳过的字符串。

#### 扫描具有结构的单词

基于状态迁移的扫描
```
SKIP: { <"/*"> : IN_BLOCK_COMMENT }
<IN_BLOCK_COMMENT> SKIP: { <~[]> }
<IN_BLOCK_COMMENT> SKIP: { <"*/"> : DEFAULT }
```
* IN_BLOCK_COMMENT 是扫描的状态（state）。
* 在规则定义中写下 { 模式：状态名 } 的话，就表示匹配模式后会迁移（transit）到对应的状态。
* DEFAULT 状态（DEFAULT state）表示扫描器在开始词法分析时的状态。

通过使用 MORE 命令，可以将一个 token 分割为由多个词法分析的规则来描述。
```
MORE: { <"/*"> : IN_BLOCK_COMMENT }
<IN_BLOCK_COMMENT> MORE: { <~[]> }
<IN_BLOCK_COMMENT> SKIP: { <"*/"> : DEFAULT }
```

### 5. 基于 javaCC 解析器的描述

#### 1. 基于 EBNF 语法的描述

编译器中解析器的作用是利用扫描器生成的 token 序列来生成语法树。

JavaCC 中将刚才的“语句”“函数调用”“表达式”等非 token 的语法单位称为非终端符(nonterminal symbol)，并将非终端符像 Java 的函数调用一样在后面加上括号写成 stmt() 或 expr()。

终端符(terminal symbol)可以归纳为 token。

这里的“符”也兼具字面表现和含义两重功能。

为什么称为终端和非终端，是因为在画语法树的图时，终端符位于树的 枝干的末端(终端)。非终端符由于是由其他符号的列组成的，因此一定位于分叉处，而非树的 末端。

JavaCC 使用名为 EBNF（Extended Backus-Naur Form）的表示法来描述语法规则。EBNF 和描述扫描器时使用的正则表达式有些相似，但比正则表达式所能描述的语法范围更广。

[] 表示可以省略

#### 2. 语法二义性和 token 的超前扫描

空悬 else 问题

JavaCC 的选择冲突（choice conflict）。

当遇到 JavaCC 的上述局限性时，应首先考虑是否可以用提取共通部分的方法来处理。但还是存在使用此方法仍然无法描述的规则，以及提取共通部分的处理非常复杂的情况，这样的情况下就可以通过接下来要讲的“token 的超前扫描”来解决。

LOOKAHEAD(2) 表示的意思为“读取 2 个 token 后，如果读取的 token 和该选项相符合，则选择该选项”。

除“选择”以外，选择冲突在“可以省略”或“重复 0 次或多次”中也可能发生。

即便写了 LOOKAHEAD 也并非一定能按照预期对程序进行分析。添加 LOOKAHEAD 后 Choice conflict 的警告消息的确消失了，但实际上 JavaCC 不会对 LOOKAHEAD 描述的内容进行任何检查。在发生选择冲突的地方加上 LOOKAHEAD 后不再显示警告，仅此而已。 LOOKAHEAD 处理的描述是否正确，我们必须自己思考。

> 几年前，说起解析器人们首先还是会想起 yacc(LALR)，但最近解析器界出现了新的流派。
> 其中之一是和 LL 解析器、LR 解析器风格截然不同的 Packrat 解析器。无论哪款 
> Packrat 解析 器，都具有如下特征。
>  1. 支持无限的超前扫描
>  2. 无需区分扫描器和解析器，可以一并编写
>  3. 内存的消耗量和字符串的长度(代码的长度)成比例 
>  4. 语法无二义性(不会发生空悬 else 的问题)

>  其二是出现了直接使用编程语言来描述语法的方法。例如 parser combinator 技术就是其中之一。 

### 6. 语法分析

#### 定义的分析

语法中一定会有表示“需要解析的对象整体”的符号。

一般编程语言的语法单位有下面这些。
*  定义(definition) 变量定义、函数定义或类定义等
*  声明(declaration)  变量定义、函数定义或类定义等
*  语句(statement) 变量定义、函数定义或类定义等
*  表达式(expression) 变量定义、函数定义或类定义等
*  项(term) 表达式中构成二元运算的一方，也就是仅由一元运算符构成的语法。

**定义包含语句，语句包含表达式，表达式包含项。**

#### 语句的分析

#### 表达式的分析

表达式的结构是有层次的。原因在于表达式中 所使用的运算符存在优先级(precedence)。

#### 项的分析

## 第二部分 抽象语法树和中间代码

### 7. JavaCC 的 action 和抽象语法树

#### JavaCC 的 action

仅有语法规则最多只能对源代码的语法进行检查。因为即便能够用语法规则来识别语句或表达式，这样的信息也不能起到任何作用。

借助 action，当 token 序列和语法规则匹配时就能够执行任意的 Java 代码。

无论终端符号还是非终端符号，获取语义值的方法都是相同的。区别在 于终端符号的语义值总是 Token 对象，而非终端符号的语义值的类则根据符号不尽相同。

action 和语义值的相关内容可以总结为如下几点。
* 使用 action 能够获取终端符号 / 非终端符号的语义值，还能够给非终端符号赋予语义值
* 终端符号的语义值为 Token 类的实例。从 Token 类的属性中可以取得 token 的字面量及其在源文件中的位置等信息
* 非终端符号的语义值取决于 action。通过在规则的开头添加语义值的类型，并从 action 返回
值，就可以设置语义值
* 当解析到规则中写有 action 之处时，action 才会被执行。若在符号串的最后写有 action，那么在该符号串全部被发现后 action 才会被执行
*  组合使用选项和 action，能够编写只有在发现特定的选项时才被执行的 action
*  组合使用重复和 action，能够编写在每次重复时都会被执行的 action

#### 抽象语法树和节点

一般编程语言的抽象语法树由名为节点(node)的数据结构组成。

### 8. 抽象语法树的生成

#### 表达式的抽象语法树

单词 LHS、RHS 是编程语言的话题中经常使用的简称，赋值的左边称为 LHS （Left-Hand-Side），右边称为 RHS（Right-Hand-Side）。

如果 x OP y OP z 的含义为 (x OP y) OP z，则称运算符 OP 为左结合（left associative），如果含义为 x OP (y OP z)，则称运算符 OP 为右结合（right associative）。

只有赋值运算符 = 是右结合的

像这样不允许 x OP y OP z 的运算符称为非结合（non-associative）运算符。Java 的 == 就是非结合的。

#### 语句的抽象语法树

#### 表达式的抽象语法树

#### 语句的抽象语法树

#### 声明的抽象语法树

#### cbc 的解析器的启动

### 9. 语义分析（1）引用的消解

对生成的抽象语法树的语义进行分析，并实施变量引用的消解和类型检查。 具体来说，我们要实施如下这些处理。
1. 变量引用的消解
2. 类型名称的消解
3. 类型定义检查
4. 表达式的有效性检查 5. 静态类型检查

### 10. 语义分析（2）静态类型检查

### 11. 中间代码的转换

## 第三部分 汇编代码

### 12. x86 架构的概要

### 13. x86 汇编器编程

### 14. 函数和变量

### 15. 编译表达式和语句

### 16. 分配栈帧

### 17 优化的方法

## 第四部分 链接和加载

### 18。 生成目标文件

### 19. 链接和库

### 20. 加载程序

### 21. 生成地址无关代码

### 22. 扩展阅读    