# Concepts, Techniques, and Models of Computer Programming

## 前言

一种学习编译的方法是学习编语言。但是编译语言太多了，只能挑选几个有代表性的不同范式的。但是这只能作为统一的训练我们对程序有一点点深入理解。本书采用另一种方法。

我们关注编程思想和使用它的技术，不关心语言。思想从术语计算模型上来组织。一个计算模型是计算过程怎么去做的正式方法。有很多方法去定义计算模型。因为本书为实践设计，因此计算模型可以用来直接使用是重要的。因此我们将在对程序员重要的思想表达方式上定义，比如数据类型，操作，和一个编程语言。术语编程模型能精确的制造编程范式的不确定性。本书剩下的部分将讨论计算模型和非编程范式。有时我们也使用习语编程模型。这涉及到编程需要什么：通过计算模型，编程技巧和设计原则是可能的。

每一个编程模型有它自己的编程技巧集和程序的推理。计算模型的数量已知的是要比编程语言的数量小的。本书覆盖了众所周知的编程模型和小众的。主要的选择标准是是否在实践中使用。

每一个计算模型都基于一个简单的核心语言叫做核心语言(kernel language).核心语言在一个逐步发展的路上，通过添加一个又一个概念。这让我们了解不同模型之间的深度关系。经常在编程中，仅仅添加一个新的思想能让世界大不同。比如，给函数式编程添加一个破坏性的任务(清晰的状态)可以去做对象导向的编程。

当步入下一个模型时，我们怎样决定思想被添加？本书会多次处理这个问题。主要是标准是创造性扩展原则。大致上，当编程因为不相关的技术原因变得复杂时去添加一个新的思想去解决问题。如果小心选择的话，添加一个思想到核心语言中去能让语言变简单。本书的核心语言基于这个原则发展。

核心语言方法一个特性是我们能使用不同的模型在同一语言里。这通常叫做多范式编程。这是自然的，这意味着对问题使用正确的思想，独立于语言的原始模型。

我们呈献三个领域：GUI设计，健壮分布式编程，约定编程。我们将显示明智的联合使用几个模型解决相应领域的问题。

我们挑选四个有代表性的计算模型：Erlang,Haskell,Java和Prolog.

## 本书的目标

用基于科学的在实践中使用的统一训练来学习编程。

编程做为一种普通的人类活动，做是扩展和改变一个系统的功能的表演。

本书关注软件系统的构建。在这个设定下，编程是一个在系统规范和实现编程之间的工作。这个步骤是由设计程序的建造和抽象并且去编码到编程语言。

编程有两个必不可少部分：技术和它的科学基础。技术包含工具，实践技巧和标准，允许我们去编程。科学包含在广度和深度的理论上让我们理解编程。科学应该能解释技术上怎么做。

不同的学校教授不同的范式，作为统一整体的编程训练丢失了。

核心编程方法通过转换实际语言到小的有意义的核心语言组成。丰富的抽象和句法集合编码进核心语言。这给编程者和学生关于语言做什么的清晰理解。核心语言有简单正式的语义让我们去推理程序的正确性和复杂性。这给了程序员一个纯的基础，并且编译技巧构造在它之上。

教学有两个互补的方法：
* 基于计算的方法 
* 基于逻辑的方法

本书和sicp一样基于计算。

添加思想是一把双刃剑。在计算模型中引入一个新的表达式可能使编程简单，但是推理可能复杂。

单一模型的具限：
* 对象导向 默认有状态，当它看起来简单和符合直觉，真相是编程变复杂了。比如它让并发变得困难。继承被滥用。
* 函数式编程 鼓励高级函数的过度使用。典型的是monads 和 currying. Monads 通过线程被编码成状态遍及系统各处。导致程序复杂而不是真正的正确状态模块化。Currying 让你应用一个函数的不完全状态通过给它参数的一部分。这返回一个有剩余参数的函数。函数在参数未完全的时候不会执行。反面是它并不清晰是否在完全参数的状态还是curried状态。
* 逻辑语言 过度使用霍恩子句（Horn Clause）.程序作为Horn Clause的集合被定义成if-then的形式，它使算法更让人迷糊。

信息学课程三个主题：
1. 思想和技术
2. 算法和数据结构
3. 程序设计和软件工程

本书详细的论述主题1和初步介绍主题2和3.经验显示程序设计应该先教,防止学生有坏习惯。

本书不包含两个主题：
* 静态类型
* 特定编程技术

## ch01 介绍编程概念
### 计算器
### 变量
### 函数 
* 递归、组合、函数抽象
### 列表 
* 模式匹配
### 列表函数 
* 主函数、辅助函数，
* **自顶向下的软件开发(1. 理解手工怎么计算，2. 写下主函数，假定辅助函数已知。3. 通过完成辅助函数解决问题。)**
### 正确性
一个程序做了我们想让它做的事情就是正确的。手工验证正确通常是不可能的。
* 验证的推理过程：
    1. 我们需要一个程序语言操作的数学模型,定义它们应该怎么做。这个模型叫做语言的语义。
    2. 我们需要定义想让程序去做什么，通常这是一个输入的数学定义和计算输出的程序需求。这叫做语言的规范。
    3. 我们使用数学技术去推理程序，使用语义。我们将验证程序满足规范。
* 验证的主要任务：
    * 编译器
    * 运行系统
    * 操作系统
    * 硬件

* 数学归纳法

### 复杂性

### 延迟计算
* lazy 关键字

### 高级函数

* 能够把函数做为参数传递被叫做高级函数

### 并发

* 通过线程(thread)

### 数据流

* 线程一个一个顺序执行。

### 状态

* 存储器单元(memory cell)

### 对象

### 类

### 非确定性和时间

* 线程的并发问题

### 原子性

* 锁

### 练习

## 声明式编程方法

* 编程包括三件事：
   1. 一个编程模型是定义语言和语言句法怎么通过虚拟机执行的正式系统。本书感兴趣的是程序的有用和易懂。
   2. 编程技巧和设计原则用来在语言的计算模型中编程，我们称之为编程模型。编程模型一定是建立在计算模型上的。
   3. 推理技术集合能让你推理编程，去增强它们表现正确和计算效率的信心。
   
* 声明式编程也叫无状态编程，相对的是有状态编程(命令式编程)
* 声明式编程的两个主要范式是函数式和逻辑式。

### 定义实际编程语言

#### 语句

* 定义合法的语句是什么。不关心实际执行什么，那是语义的事。
* 语法 是从词到句子的规则集。对于编程语言来说，句子一般叫‘statments’，单词叫做‘tokens’。语法同时使用 statments 和 tokens.
> statement (‘sentence’)= sequence of tokens (‘words’)
> token (‘word’)        = sequence of characters (‘letters’)
* 一个程序从字符序列转换成token序列的过程叫做词法分析(tokenizer or lexical analyer).
* Extended Backus-Naur Form 扩展巴科斯-诺尔范式 EBNF
  * 终端符是一个token，非终端符是tokens的序列。
  * 非终端符通过语法规则定义。| 表示或者，大括号表示0或多个。
  * 读语法从左到右： 
    * 每个终端符被添加进序列
    * 每个非终端符用tokens序列替换。
    * 每次遇到选择，挑选它们任意一个。
* 任何明确的句子定义叫做正式语言和短语。上下文无法和上下文敏感。
* 上下文无关的语法可能是含混不清的。消除岐义的方法是优先级和结合性。
  * 优先级 不同操作符在同一个表达式中的判断，每个操作符有一个优先级别。
  * 结合性 是同一操作符在同一表达式中的判断，结合性确定左结合还是右结合。
* 符号设计满足两个基本原则：
  * 所有的语法规则都是它们自己的。之后的改变不会改变。
  * 当一个编程规则彻底定义一个非终端符号或者它仅仅是一个实际定义时它一直是清晰易懂。

#### 语义

* 程序的语义定义当它执行的时候程序做什么。理想情况下，语义应该被定义在一个简单的数学结构让我们不引入任务不相干的明细能推理程序.
* 核心语言方法由两个部分组成：
  * 首先定义一个非常简单的语言，叫做核心语言。
  * 第二定义一个从全部语言到核心语言的转换方案。转换方式有两种语言抽象和语法糖。
  
* 正式语义 有四个广泛使用的方法：
  * 操作语义(operational semantics)显示在抽象机器上声明怎么执行。
  * 公理语义(axiomatic semantics)定义声明的语义作为输入和输出之间的关系。
  * 指称语义(denotational semantics)定义声明作为一个函数在抽象领域。
  * 逻辑语义(logical semantics)定义声明作为一个逻辑定理的模型。
