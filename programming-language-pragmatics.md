# Programming Language Pragmatics 程序语言实践

## FOUNDATIONS

### 1 Introduction

机器语言是直接控制处理器，在合适的时间让它从一个地方到另一个地方加，比较，移动数据等等操作的二进制序列。

#### The Art of Language Design

为什么有那么多的语言：
* 进化
* 特定目地
* 个人喜好

语言怎么成功：
* 强有力的
* 易于使用对新手
* 易于实现
* 标准化
* 开源
* 高效的编译器
* 经济，实惠和惰性

#### The Programming Language Spectrum

声明式编程关注计算机做什么，命令式编程关注计算机械怎么做。

命令式编程占主要优势的主要原因是性能。

重要子类型
* 函数式语言 基于递归定义，灵感来之于 lambda calculus。
* 数据流语言 
* 逻辑或约束语言
* 冯 诺依曼语言
* 脚本语言
* 对象导向语言

函数式编程里最重要的是输入和输出的数学关系。

在逻辑语言里，程序指定一个原理集和允计系统找到想得到的值的证明规则。

#### Why Study Programming Languages?

对于一件事情来说，对语言的设计和实现一个好的理解能帮助我们选择更合适的语言来完成任务。

无论你学习什么语言，理解它的设计和实现能让你更好的使用它。本书帮助你：
* 理解难以理解的特性
* 选择另一种可替代的方式去表达事情
* 更好的使用调试，汇编，链接和关系工具
* 模拟语言中缺失的有用特性
* 无论在什么情况下都能更好的使用语言技术

#### Compilation and Interpretation

编译器转换高级源代码程序到等值的目标语言程序，然后执行它们。

许多编译器生成汇编语言代替机器语言，因为汇编语言易于调试，易于阅读，并且同机器语言文件独立。

C 编译器开始于能删除注释和展开宏的预处理器。

C++ 实现基于早期的 AT&T 编译器，生成的是一个 C 的中间程序，替代汇编语言。

许多编译器是自举的(self-hosting)：它们被写于它们编译的语言。

#### Programming Environments

编辑器 IDE

#### An Overview of Compilation

1. Lexical and Syntax Analysis 扫描器读取字符串并把它们分组进单词。扫描器也叫做词法分析。扫描器是为了简化解析器的任务。通过规约输入的大小并且删除无关的字符像空白符。解析器把单词组织成一个用高级构造(声明，表达式，子程序等等)解析树。每个结构是一个结点，它的成份是子结点。树的根结点是简单的程序；叶子从左到右，是扫描器得到的单词。一个可能的构造规则集叫做和上下文无关文法。每个规则有一个箭头符号(->)，左边是名字，右边是可能的表达式。上下文无关的文法用来表示语言的句法，解析器为此所做的是句法分析。
2. Semantic Analysis and Intermediate Code Generation 语义分析是找到语言的意义。
3. Target Code Generation 转换中间语言到目标语言。
4. Code Improvement

#### Summary and Concluding Remarks

#### Bibliographic Notes

### 2 Programming Language Syntax

不像自然语言，计算机语言必须精确。它们的形式(句法)和意义(语义)必须是没有歧义的说明，这样程序员和计算机才能告诉育种应该做什么。

区分句法和语义是有用的，至少有两个原因：首先不同的语言经常提供相同的语义但是用不同的句法。第二，编译器或解释器能使用发现计算机程序的句法结构的高效简洁算法，它能被用在后续的处理过程中。

#### Specifying Syntax: Regular Expressions and Context-Free Grammars

句法的正式规范需要一个规则集。

单词(token)是基本的程序构造块，有单独意思的最短字符串。包括关键字(keywords),标识符(identifiers)，符号(symbols),和各种类型的常量。

对于特定单词，我们使用正则表达式表示，有下面几种：
1. 一个字符
2. 空字符串用 ℇ 表示
3. 两个正则表达式连着，表示第一个后面是第二个
4. 两个正则表达式通过 | 分隔，意思是其中任意一个
5. 一个正则表达式后面跟着 *，表示零个或多个
圆括号放在多个子表达式的开始和结尾用来避免歧义，例如数字的句法：
```
number −→ integer | real
integer −→ digit digit *
real −→ integer exponent | decimal ( exponent | ℇ ) 
decimal −→ digit * ( . digit | digit . ) digit * 
exponent −→ (e|E)(+|-| ℇ) integer
digit −→ 0|1|2|3|4|5|6|7|8|9
```

正则表达式对于定义单词工作的很好，但是对于嵌套结构无能为力，然而这是程序语言最重要的。

在上下文无关方法中每个规则叫做产生式。产生式的左边符号是变量或者非终端符。可能会有签单的产生式有相同的左边。来之于方法的字符串叫做终端符，它们不会出现的左边。在程序语言中，上下文无关文法的终端符是语言的单词。非终端符中的一个，通常是第一个产生式的左边的一个，被叫做开始符号。它通过综合方法定义。

一个上下文无关文法显示怎么生成一个正当的符合文法的终端字符串：用开始符号开始。

算术操作中的结合性和优先级。

#### Scanning

扫描器和解析器对于发现程序语言的句法结构是责任重大的。发现的过程或句法分析是转换程序到等值的目标语言必要的第一步。

通过分组字符到单词，扫描器归纳出独立的能通过解析器检查的项。接下来扫描器删除注释；保存有用的单词；并且标记单词的行列号，以便在随后的阶段容易生成变质量的错误信息。

扫描器使用最长匹配原则。

有限自动机能从正则表达式自动生成，当单词定义改变时，它是容易的随之改变。

通过扫描器生成工具可以从正则表达式构造有限自动机。

典型的扫描器生成器实现转换分三步：第一步转换正则表达式到非确定有限自动机(NFA)，第二步扫描器生成器转换NFA到等值的DFA，第三步是空间优化，使用可能最小的状态生成最后的DFA。


#### Parsing

解析器是编译器的核心。它调用扫描器获得输入程序的单词，把单词组装在一起形成一个语法树，然后传递树给编译器的后续阶段，语义分析，代码生成，改进。

解析算法的分类 LL(从左到右，最左推导) 和 LR(从左到右，最右推导)。

LL 解析器也叫做从顶向下或预测解析。从根结点构造树，预测当前结点的下一步，基于下一个输入。LR 解析器也叫做从底向上解析器，它从叶子上构造树，当一个叶子的集合或其它结点能一起做为单一父结点的子结点连接在一起。

**需要加强理解，后续**

#### Theoretical Foundations

**自动机理论，需要单独理解**

正则表达式等值自动机

#### Summary and Concluding Remarks

### 3 Names, Scopes, and Bindings

#### The Notion of Binding Time

binding 关系到两个事情，名字和它命名的事情。绑定时间是绑定创建的时间。有几种不同的绑定：
* 语言设计时：许多语言中，控制流构造，标准类型集，对复杂类可用的构造子和其它的语义是在语言设计时确定的。
* 语言实现时：许多语言把决定权放到实现者的手上。典型的 I/O 到操作系统文件的连接。
* 程序编写时：程序员选择算法，数据结构，名字。
* 编译时：编译器映射高级构造到机器码，包含内存中的静态定义结构。
* 链接时：
* 加载时：虚拟地址在链接时，物理地址在运行时
* 运行时：

术语静态和动态通常是指运行前和运行中。

基于编译的语言经基于解释器的语言更高效，因为它们提前做出决定。比如编译器在运行前一次分析全部的变量定义的句法和语义。它决定变量在内存中的布局，并高效的处理它们。一个纯的解释器必须在程序开始前每次执行分析。

#### Object Lifetime and Storage Management

关键事件：
* 对象创建
* 绑定创建
* 引用变量，子程序，类型等等使用绑定的全部
* 对暂时不用的绑定的暂停和重新激活
* 解除绑定
* 毁灭对象
在命名对象绑定的创建和销毁的时间区间叫做绑定的生命周期。相同的，对象的创建和销毁时间段叫做对象的生命周期。

三种分配对象存储的机制：
* 静态 对象得到一个绝对的地址，保留在程序执行时期
* 栈 分配和解除分配后进先出顺序，通常相关联的是子程序的调用和返回
* 堆 分配和解除分配可能是任意时间

静态分配对象在运行时不会被改变。经常被分配为受保护的，只读内存，因此任何由于疏忽对它们的写操作会导致处理器中断，允许操作系统报出索运行时错误。

栈在许多语言实现中是向下生长，

#### Scope Rules

静态作用域
* 大部分语言的作用域是静态的(在编译时确定)

嵌套子程序

声明顺序
* 声明和定义
* 嵌套块

模块化
* 封装数据和子程序
* 模块做为抽象
* 导入和导出
* 模块做为管理

模块类型和类
* 面向对象
* 模块包含类

动态作用域
* 在运行时确定 给定名字的当前绑定是最近执行的，并且返回后不会销毁。

#### Implementing Scope

在静态作用域程序中保持命名的足迹，编译器依赖一个叫做符号表的数据抽象。本质上，符号表是字典。它映射名字到编译器知道的它的信息。最基本的操作是插入新的(名称与对象绑定)或通过给定的名字查找相对应的信息。

#### The Meaning of Names within a Scope

两个或更多名称引用程序中相同的对象叫做别名。一个名称引用了一个以上的对象叫做超载。

多态表示有多种形式。泛型的使用。

#### The Binding of Referencing Environments

静态作用域中引用环境依赖于名字声明处的程序的词法嵌套块。动态作用域的规则是引用环境依赖于运行时定义在哪里的顺序。

#### Macro Expansion

#### Separate Compilation

#### Summary and Concluding Remarks

句法关注有效程序的形式，语义关注它的意义。

### 4 Semantic Analysis

语义分为静态语义和动态语义，尽管分隔线比较模糊。编译器在编译时强制执行静态语义匹配，它生成的代码在运行时强制执行动态语义匹配。

#### The Role of the Semantic Analyzer

语义分析和中间代码生成的分隔就是编译器前端和后端的分隔。

编译时的算法预测运行时的行为叫做静态分析。

#### Attribute Grammars

#### Evaluating Attributes

对属性求值的过程叫做解析树的注解或装饰。

合成属性

继承属性

属性流

#### Action Routines

####　Space Management for Attributes

#### Decorating a Syntax Tree

### 5 Target Machine Architecture

一个编译器就是一个翻译器，它转换一个语言到另一个语言。

## CORE ISSUES IN LANGUAGE DESIGN

### 6 Control Flow

### 7 Data Types

### 8 Subroutines and Control Abstraction

### 9 Data Abstraction and Object Orientation

## ALTERNATIVE PROGRAMMING MODELS

### 10 Functional Languages

### 11 Logic Languages

### 12 Concurrency

### 13 Scripting Languages

## A CLOSER LOOK AT IMPLEMENTATION

### 14 Building a Runnable Program

### 15 Run-time Program Management

### 16 Code Improvement

