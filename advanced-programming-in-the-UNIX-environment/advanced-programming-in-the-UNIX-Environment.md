# UNIX 环境高级编程

## UNIX 基础知识

### UNIX 体系结构

* 操作系统是一种控制计算机硬件资源，提供程序运行环境。通常叫做内核(kernel)。内核的接口称为系统调用(system call)。公共库函数构建在系统调用接口上，应用程序既可使用公用程序库，也可使用系统调用。shell 是一个特殊的应用程序，为运行其他应用程序提供了一个接口。

### 登录

* 用户在登录UNIX系统时，先输入用户名，然后输入口令。系统在其口令文件(/etc/passwd)中查看登录名。口令文件上的登录项由7个以冒号分隔的字段组，依次是：登录名、加密口令、数字用户ID、数据组ID、注释字段、起始目录、以及shell程序:

```bash
sar:x:205:105:Stephen Rago:/home/sar:/bin/ksh
```

* 用户登录后，系统通常显示一些系统信息，然后用户可以向shell输入命令。shell是一个命令行解释器，它读取用户输入，然后执行命令。shell的用户输入通常来自终端(交互式shell),有时来自于文件(shell脚本).系统中存在多个shell。

### 文件和目录

* UNIX文件系统是目录和文件的一种层次结构，所有东西的起点是称为根(root)的目录，这个目录的名称是一个字符“/”。

* 目录(directory)是一个包含目录项的文件。逻辑上，可以认为每个目录都包含一个文件名，同时还包含说明该文件属性的信息。文件属性是指文件类型、文件大小、文件所有者、文件权限以及文件最后的修改时间等。

* 目录中的各个名字称为文件名。只有斜线(/)和空字符这两个字符不能出现在文件名中。斜线用来分隔构成路径的各文件名，空字符则用来终止一个路径名。

* 创建新目录时会自动创建两个文件名:.(点)和..(点点)。点指向当前目录，点点指向父目录。最高层次时点与点点相同。

* 路径名，由斜线分隔的一个或多个文件名组成的序列构成，以斜线开头的路径名称为绝对路径，否则为相对路径名。

* 每个里程都有一个工作目录(working directory)，有时称其为当前工作目录(current working directory)。所有相对路径名都从工作目录开始解释.进程可以用 chdir 函数更改其工作目录.

* 登录时，工作目录设置为起始目录(home directory)。

### 输入和输出

* 文件描述符(file descriptor) 通常是一个小的非负整数，内核用以标识一个特定进程正在访问的文件。当内核打开一个现有谁的或创建一个新文件时，它都返回一个文件描述符。在读、写文件时，可以使用这个文件描述符。

* 标准输入、标准输出和标准错误。按惯例，每当运行一个新程序时，所有 shell 都为为其打开 3 个文件描述符，即标准输入（standard input）、标准输出（standard output）以及标准错误（standard error）。如果不做特殊处理，这 3 个描述符都链接向终端。
* 函数 open、read、write、lsekk以及close提供了不带缓冲的I/O。这些函数都使用文件描述符。
* 标准I/O。为那些不带缓冲的I/O函数提供一个缓冲的接口。

### 程序和进程

* 程序是一个存储在磁盘上某个目录中的可执行文件。内核使用exec函数（7个exec函数之一），将程序读入内存并执行程序。
* 进程和进程ID。敋以的执行实例称为进程（process）。UNIX系统确保每一个进程都有一个唯一的数字标识符，称为进程ID（process ID）。进程ID总是一个非负整数。
* 进程控制，有三个用于进程控制的主要函数：fork、exec和waitpid（exec函数有7种变体）。
* 线程和线程ID。通常一个进程只有一个控制线程（thread）-某一时刻执行的一组机器指令。一个进程内的所有线程共享同一地址空间、文件描述符、栈以及与进程相关的属性。因为它们能访问同一存储区，所以各线程在访问共享数据时需要采取同步措施以避免一不致性。线程也用ID标识。但是线程ID只在它所属的进程内起作用。一个进程中的线程ID在另一个进程中没有意义。当在一进程中对某个特定线程进行处理时，我们可以使用线程的ID引用它。控制线程和函数和控制进程的函数类似，但另有一套。

### 出错处理

* 当UNIX系统函数出错时，通常会返回一个负值，而且整形变量errno通常被设置为具有特定信息的值。
* 出错可分为两类：致命性的和非致命性的。 对于致命性的错误，无法执行恢复动作。

### 用户标识

* 用户ID。一个数值，向系统标识各个不同的用户。系统管理员在确定一个用户的登录名的同时，确定其用户ID。用户不能更改其用户ID。ID 为0的用户为根用户（root）或超级用户（superuser）。
* 组ID。一个数值。由系统管理员在指定用户登录名时分配。组文件将组名映射为数值的组ID，组文件通常是 /etc/group。
* 附属组ID。用户带可以属于另一个组。

### 信号

信号（signal）用于通知进程发生了某种情况。终端键盘上有两种产生信号的方法，分别是中断键（interrupt key，通常是Delete键或Ctrl+c）和退出键（quit key，通常是Ctrl+\）。它们用于中断当前运行的进程。另一种产生信号的方法是调用 kill 函数。

### 时间值 

UNIX使用过两种不同的时间值：

* 日历时间。该值是自协调世界时（Coordinated Universal Time, UTC）1970年1月1日00:00:00这个特定时间以来所经过的秒数累计值。系统基本数据类型 time_t 用于保存这种时间值。
* 进程时间。也被称为CPU时间，用以度量进程使用的中央处理器资源。进程时间以时钟滴答计算。每秒钏曾经取为50、60和100个时钟滴答。系统基本类型clock_t保存这促时间值。

当度量一个进程的执行时间时，UNIX系统为一个进程维护了3个进程时间值：

* 时钟时间。又称为墙上时钟时间（wall clock time），它是进程运行时间的总量，其值与系统中同时运行的进程数有关。
* 用户CPU时间。执行用户指令所用的时间。
* 系统CPU时间。该进程执行内核程序所经历的时间。

### 系统调用和库函数

系统提供的服务入口点，由此向内核请求服务。使用C语言定义。为每个系统调用在标准C库中设置一个相同名字的函数。用户进程用标准C调用序列来调用这些函数，然后函数又用系统所要求的技术调用相应的内核服务。

从实现者角度，系统调用和库函数有根本的区别，但是对用户来说，并不重要。我们可以替换库函数，但系统调用不可以。

以存储空间分配函数 malloc 为例。有多种愿意付出可以进行存储空间分配及其相关的无用空间回收操作，并不存在对所有程序的最优解。UNIX系统调用中处理存储空间分配的是 sbrk，它不是一个通用的存储器管理器。它按指定字节数增加或减少进程地址空间。如何管理该地址空间取决于进程。你可以定义自己的 malloc 函数，它很有可能将使用 sbrk 系统调用。

内核中的系统调用分配一块空间给进程，而库函数 malloc 则在用户层次管理这一空间。

## UNIX 标准及实现

### IEEE POSIX 

POSIX 指的是可移植操作系统接口。

## 文件I/O

5个I/O函数：open、read、write、lseek以及close。

### 文件描述符

对内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数。当打开一个现有文件或创建一个新文件时，内核进程返回一个文件描述符。当读写一个文件时，使用open或create返回文件描述符标识该文件，将其做为参数传递给read或write。

UNIX shell 把文件描述符0与进程的标准输入关联，1与标准输出关联，2与标准错误关联。这是惯例。

符合POSIX.1的程序，0替换为符号常量STDIN_FILENO,1对应STDOUT_FINEN，2对应STDERR_FINENO,这些常量在头文件<unistd.h>中定义。

### 函数open和openat

```c
#include <fcntl.h>
int open(const char *path, int oflag,...);
int openat(int f d, const char *path, int oflag,...)
```

两个函数返回值：若成功，返回文件描述符；若出错，返回 -1。path 参数是要打开或创建文件的名字。oflag 参数可用来说明此函数的多个选项。

f d 参数把open 和 openat 函数区分开，有三种可能：

1. path是绝对路径，fd 忽略，相当于一样的函数。
2. path 相对路径，fd 指出了相对路径名在文件系统中的开始地址。fd参数是通过打开相对路径名所在的目录来获取。
3. path 相对路径， fd值为 AT_FCDWD。这时，路径名在当前工作目录取，openat 和 open类似。

openat 希望解决两个问题：让线程可以使用相对路径名打开目录中的套件，而不再只能打开当前工作目录。同一进程中的所有线程共享相同的工作目录。第二，可以避免itme of check-to-time-user(TCCTTOUl)错误。TOCTTOU错误的基本思想是：如果有两个基于文件的调用，其中第二个调用依赖于第一个的结果，那么程序是脆弱的。因为两个调用并不是原子操作，在两个调用之间文件可能改变了，这样会造成了第一个调用的结果就不再有效，使得程序最终的结果是错误的。

### 函数 creat

```c
#include <fcntl.h>
int create(const char *path, mode_t mode);
```

此函数等效于

```c
open(path, 0_WRONL | 0_CREAT | 0_TRUNC, mode);
```

create 的不足：它以只写方式打开所创建的文件。

### 函数close

可调用关闭一个打开文件。

```c
#include <unistd.h>
int close (int fd);
```

关闭一个文件时还会释放该进程加在该文件上的所有记录锁。当一个进程终止时，内核会自动关闭它所有的打开文件。

### 函数 lseek

每个打开文件都有一个与其关联的“当前文件偏移量”（current file offset）。它通常是非负整数，用以度量从文件开始计算的字节数。通常读、写操作都是从当前文件偏移量处开始，并使偏移量拉回所读写的字节数。系统默认，除非指定 0_APPEND，否则该偏移量为0。

```c
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence);
```

对参数offset的解释与 whence 有关：

* 若whence是SEEK_SET，则将该文件的偏移量设置为距文件开始处offset个字节。
* 若whence是SEEK_CUR，则将该文件的偏移量设置为其当前值加 offset，offset 可为正或负。
* 若whence是SEEK_END，则将该文件的偏移量设置为文件长度加offset，offset 可正可负。

若 lseek 成功执行，则返回新的文件偏移量，为此可用下列方式确定打开文件的当前偏移量：

```c
off_t currpos;
currpos = lseek(fd, 0, SEEK_CUR);
```

通常文件的当前偏移量应当是一个非负整数，但是某些设备也可能允许负的偏移量。但对于普通文件，其偏移量必须是非负值。因为偏移量可能是负值，所以在比较 的返回值时应当谨慎，不要测试它是否小于0，而要测试它是否小于 -1。

lseek 仅将当前的文件偏移量记录在内核中，它并不引起任何 I/O 操作。然后，该偏移量将用于下一个读或写操作。

文件偏移量可以大于文件的当前长度，在这种情况下，对该文件的下一次写将加长该文件，并在文件中构成一个空洞，这一点是允许的。位于文件中但没有写过的字节都被称为 0。

文件中的空洞并不要求在磁盘上占用存储区。具体处理方式与文件系统的实现有关。

### 函数 read

read 从打开文件中读数据

```c 
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t nbytes);
```

如果 read 成功，则返回读到的字节数。如到结尾，返回0。

实际读到字节数少于要求读的字节数：

* 读普通文件，在读到要求的字节数前就已经到了文件末尾。
* 从终端设备读时，通常一次最多读一行。
* 当从网络读里，网络中的缓冲机制可能造成返回值小于所要求的字节数。
* 当从管道或FIFO读时，如若管道包含的字节少于所需数据，read 将只返回实际可用的字节数。
* 当从某些面向记录的设备读时，一次最多返回一个记录。
* 当一信号造成中断，而已经读了部分数据量时。

POSIX 从几个方面对 read 函数的原型做了修改

```c
int read(int fd, char *buf, unsigned nbytes);
```

* 首先，为了与ISO C 一致，第2个参数由 char * 改为 void *。在 ISO C 中void * 代表通用指针。
* 其次，返回值必须是一个带符号整型，以保证能够返回正整数字节数、0（文件末端）或-1（出错）。
* 第3个参数在历史上是一个无符号整型，这允许一个16位的实现一次读或写的数据可以多达 65534个字节。

### 函数 write

向打开文件写数据

```c
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t nbytes);
```

返回值通常与参数 nbytes 的值相同，否则表示出错。

### I/O 的效率

```c
#include "../apue.h"

#define BUFFSIZE 4096

int main(void)
{
  int n;
  char buf[BUFFSIZE];

  while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) > 0)
    if (write(STDOUT_FILENO, buf, n) != n)
      err_sys("read error");

  if (n < 0)
    err_sys("read error");

  exit(0);
}
```

几点注意：

* 它从标准输入读，写到标准输出，这就假定在执行本程序之前，这些标准输入、输出已由 shell 安排好。
* 考虑到进程终止时，UNIX 系统内核会关闭进程的所有打开的文件描述符，所以此程序不关闭输入和输出文件。
* 对 UNIX 系统内核而言，文本文件和二进制代码并无区别，所以本程序对两种文件都有效。

### 文件共享

UNIX 系统支持在不同进程间共享打开文件。

内核使用三种数据结构表示打开文件，它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响。

1. 每个进程在进程表中都有一个记录项，记录项中包含一张打开文件描述符表，可将其视为一个矢量，每个描述符占用一项。与每个描述符相关联的是：
   1. 文件描述符标志（close_on_exec）
   2. 指向一个文件表项的指针。
2. 内核为所有打开文件维持一张文件表。每个文件表项包含：
   1. 文件状态标志（读、写、添写、同步和非阻塞等）
   2. 当前文件偏移量
   3. 指向该文件 v 节点表项的指针
3. 每个打开文件（或设备）都有一个 v 节点（v-node）结构。v 节点包含文件类型和对此文件各种操作函数的指针。v 节点可能还包含该文件的 i 节点（i-node，索引节点）。这些信息是打开文件时从磁盘上读入内存的，所以文件的所有相关信息都是随时可用的。linux 没有使用 v 节点，全是 i 结点。

## 文件和目录

## 标准I/O库

## 系统数据文件和信息

## 进程环境

## 进程控制

## 进程关系

## 信号

## 线程

## 线程控制

## 守护进程

## 高级I/O

## 进程间通信

## 网络IPC: 套接字

## 高级进程间通信

## 终端I/O

## 伪终端

## 数据库函数库

## 与网络打印机通信