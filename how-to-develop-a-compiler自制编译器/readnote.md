
# 自制编译器 

### 1. 开始制作编译器

编译器是将编程珏的代码转换为其他形式的软件。转换操作称为编译。

4个阶段：
1. 预处理
2. 编译（狭义的）
3. 汇编
4. 链接

狭义的编译的四个阶段
1. 语法分析
2. 语义分析
3. 生成中间代码
4. 代码生成

### 2. Cb和cbc



## 第一部分 代码分析

### 3. 语法分析的概要

#### 1. 语法分析的方法

词法分析(lexical analyze)就是将代码分割为一个个的单词，也可以称为扫描(scan)。

负责词法分析的模块称为词法分析器(lexical analyzer)，又称扫描器(scanner)。

扫描器的工作不仅仅是将代码分割成单词，在分割的同时还会推算出单词的种类，并为单 词添加语义值。

语义值(semantic value)表示单词所具有的语义。

另外，也有一些单词本身不存在语义值。例如，对于保留字 int 来说，“保留字 int”这 样的种类信息已经完全能够表示语义，不需要额外的语义值。

在编程语言处理系统中，我们将“一个单词(的字面)”和“它的种类”“语义值”统称为 token。通过使用 token 这个词，词法分析器的作用就可以说是解析代码(字符行)并生成 token 序列。

编程语言的编译器中解析器的主要作用是解析由扫描器生成的 token 序列，并生成代码所 对应的树型结构，即语法树。

#### 2. 解析器生成器

生成扫描器的程序称为扫描器生成器（scanner generator），生成解析器的程序称为
解析器生成器（parser generator）。

扫描器生成器都大体类似，解析器生成器则有若干个种类。现在具有代表性的解析器生成
器可分为 LL 解析器生成器和 LALR 解析器生成器两类。

种类  | 可处理的语法范围 | 速度
---- | -------------- | ----
LR   | 广             | 一般
LALR | 相对狭窄        | 一般
LL   | 较窄            | 较快

#### 3. JavaCC 的概要

JavaCC 是 LL 解析器生成器，因此比起 LR 解析器生成器和 LALR 解析器生成器，它有着 可处理语法的范围相对狭窄的缺点。但另一方面，JavaCC 生成的解析器有易于理解、易于使用 的优势。另外，因为支持了“无限长的 token 超前扫描”，所以可处理语法范围狭窄的问题也得 到了很好的改善，
    
### 4. 词法分析

#### 1. 基于 JavaCC 扫描器的描述

JavaCC 采用正则表达式(regular express)的语法来描述需要解析的单词的规则，并由此来表现扫描器。

#### 2. 扫描没有结构的单词

JavaCC 中扫描 token 要像下面这样使用 TOKEN 命令(TOKEN directive)，并排记载 token 名和正则表达式。

```
TOKEN: {
      <token名1 : 正则表达式1>
    | <token名2 : 正则表达式2>
    | <token名3 : 正则表达式3>
          .
          .
          .
    | <token名n : 正则表达式n> 
}
```

JavaCC 会同时尝试匹配所有的 正则表达式，并选择匹配字符串最长的规则

#### 扫描不生成 token 的单词

不使用 TOKEN 命令而使用 SKIP 命令的话就不会生成 token，因此使用 SKIP 命令可以省 略 token 名。

还可以用 SPECIAL_TOKEN 命令(SPECIAL_TOKEN directive)来跳过 token。SKIP 命令 和 SPECIAL_TOKEN 命令的区别在于是否保存跳过的 token。使用 SKIP 命令无法访问跳过的字 符串，使用 SPECIAL_TOKEN 命令就可以借助下面被扫描的 TOKEN 对象来取得跳过的字符串。

#### 扫描具有结构的单词

### 5. 基于 javaCC 解析器的描述

#### 1. 基于 EBNF 语法的描述

JavaCC 中将刚才的“语句”“函数调用”“表达式”等非 token 的语 法单位称为非终端符(nonterminal symbol)，并将非终端符像 Java 的函数调用一样在后面加上 括号写成 stmt() 或 expr()。

终端符(terminal symbol)可以归纳为 token。

为什么称为终端和非终端，是因为在画语法树的图时，终端符位于树的 枝干的末端(终端)。非终端符由于是由其他符号的列组成的，因此一定位于分叉处，而非树的 末端。

EBNF 和描述扫描器时使用的正则表达式有些相似，但比正则表达式所能描述的语法范围更广。

#### 2. 语法二义性和 token 的超前扫描

即便写了 LOOKAHEAD 也并非一定能按照预期对程序进行分析。添加 LOOKAHEAD 后 Choice conflict 的警告消息的确消失了，但实际上 JavaCC 不会对 LOOKAHEAD 描述的 内容进行任何检查。在发生选择冲突的地方加上 LOOKAHEAD 后不再显示警告，仅此而已。 LOOKAHEAD 处理的描述是否正确，我们必须自己思考。

> 几年前，说起解析器人们首先还是会想起 yacc(LALR)，但最近解析器界出现了新的流派。
> 其中之一是和 LL 解析器、LR 解析器风格截然不同的 Packrat 解析器。无论哪款 
> Packrat 解析 器，都具有如下特征。
>  1. 支持无限的超前扫描
>  2. 无需区分扫描器和解析器，可以一并编写
>  3. 内存的消耗量和字符串的长度(代码的长度)成比例 
>  4. 语法无二义性(不会发生空悬 else 的问题)

>  Packrat 解析器可以说是今后的潜力股。 其二是出现了直接使用编程语言来描述语法的方法。> 例如 parser combinator 技术就是其中之一。 

### 6. 语法分析

#### 定义的分析

语法中一定会有表示“需要解析的对象整体”的符号。

一般编程语言的语法单位有下面这些。
*  定义(definition) 变量定义、函数定义或类定义等
*  声明(declaration)  变量定义、函数定义或类定义等
*  语句(statement) 变量定义、函数定义或类定义等
*  表达式(expression) 变量定义、函数定义或类定义等
*  项(term) 表达式中构成二元运算的一方，也就是仅由一元运算符构成的语法。

**定义包含语句，语句包含表达式，表达式包含项。**

#### 语句的分析

#### 表达式的分析

表达式的结构是有层次的。原因在于表达式中 所使用的运算符存在优先级(precedence)。

#### 项的分析

## 第二部分 抽象语法树和中间代码

### 7. JavaCC 的 action 和抽象语法树

### 8. 抽象语法树的生成

### 9. 语义分析（1）引用的消解

### 10. 语义分析（2）静态类型检查

### 11. 中间代码的转换

## 第三部分 汇编代码

### 12. x86 架构的概要

### 13. x86 汇编器编程

### 14. 函数和变量

### 15. 编译表达式和语句

### 16. 分配栈帧

### 17 优化的方法

## 第四部分 链接和加载

### 18。 生成目标文件

### 19. 链接和库

### 20. 加载程序

### 21. 生成地址无关代码

### 22. 扩展阅读    